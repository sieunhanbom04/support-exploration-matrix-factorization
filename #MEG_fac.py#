import numpy as np
#from pyfaust import *
import time
import matplotlib.pyplot as plt

def projection(A, k):
    result = np.zeros(A.shape)
    order = np.argsort(np.absolute(A), axis = 0)
    row_index = order[-k:].T.flatten()
    col_index = np.tile(np.arange(A.shape[1]).astype(int), (k, 1)).T.flatten()
    result[row_index, col_index] = 1
    return result 

def HTP(A, C, k, max_iter = 50, mu = 1e-3, use_proj = False, grad_iter = 10, step = 1e-3):
  x = np.zeros((A.shape[1], C.shape[1]))
  B = np.dot(A.T, A)
  z = np.dot(A.T, C)
  
  for i in range(max_iter):
    temp = x + mu * (z - np.dot(B, x))
    #print(temp)
    alive = projection(temp, k)
    
    new_x = np.zeros(x.shape)
    if use_proj:
      for j in range(x.shape[0]):
        support = np.argsort(alive[:, j])[-k:]
        new_x[support, j] = np.dot(np.linalg.pinv(A[:, support]), C[:, j])
    else:
      new_x = x * 1.0
      for j in range(grad_iter):
        new_x = np.multiply(new_x + step * (z - np.dot(B,new_x)), alive)

    x = new_x
  return x

def BHTP(M, k0, k1, lr = 1e-4, max_iter = 1000, flag = True):
    B = np.eye(M.shape[1], M.shape[1]) 
    A = np.eye(M.shape[0], M.shape[1])
    
    evol = []
    
    bestA = np.zeros(A.shape)
    bestB = np.zeros(B.shape)
    score = 1.0
    
    for i in range(max_iter):
        
        if i % 100 == 0 and flag:
            suppA = np.where(A!=0, 1, 0)
            temp = HTP(B.T, M.T, k0, step = 1e-3).T
            suppAnew = np.where(temp!=0, 1, 0)
            if i ==0 or np.sum(np.abs(suppA - suppAnew)) > 1e-3:
                A = temp
            
            suppB = np.where(B!=0, 1, 0)
            temp = HTP(A, M, k1, step = 1e-4)
            suppBnew = np.where(temp!=0, 1, 0)
            if i ==0 or np.sum(np.abs(suppB - suppBnew)) > 1e-3:
                B = temp
        
        normA = np.linalg.norm(A)
        normB = np.linalg.norm(B)
        A = A * np.sqrt(normB / normA)
        B = B * np.sqrt(normA / normB)
        
        supportA = np.where(np.absolute(A) > 1e-17, 1, 0)
        supportB = np.where(np.absolute(B) > 1e-17, 1, 0)

        for loz in range(20):
            adaptlr = (1 + 1e-3) * np.linalg.norm(B, ord = 2) ** 2
            A = A - (1 / adaptlr) * (A @ B - M) @ B.T
            suppA = projection(A.T,k0).T
            A = A * suppA 
    
            adaptlr = (1 + 1e-3) * np.linalg.norm(A, ord = 2) ** 2
            B = B - (1 / adaptlr) * np.dot(A.T, A @ B - M)
            suppB = projection(B,k1)
            B = B * suppB
        rekt = np.linalg.norm(np.dot(A,B) - M) / np.linalg.norm(M)
        evol.append(rekt)
        if score > np.linalg.norm(np.dot(A,B) - M) / np.linalg.norm(M):
            score = np.linalg.norm(np.dot(A,B) - M) / np.linalg.norm(M)
            bestA = A 
            bestB = B 
        print("Iteration ", i, ": ", np.linalg.norm(np.dot(A,B) - M) / np.linalg.norm(M))
    print(score)
    
    return evol

if __name__ == '__main__':
    MEG = np.load('MEG.npy')
    #print(MEG.shape)
    #MEG = np.load('gaussian1.npy')
    #MEG = Faust(MEG).T.normalize(2).toarray().T
    #print(np.linalg.norm(MEG))
    #A,B = MEG_fac(MEG, 5, max_iter = 2000)
    #_ = MEG_fac2(MEG, 100, 25, max_iter = 100)
    #_ = MEG_fac2(MEG, 100, 25, max_iter = 100, flag = False)
    #MEG = np.load('gaussian.npy')
    evol1 = MEG_fac(MEG, 25, 25, max_iter = 100, flag = False)
    evol2 = MEG_fac2(MEG, 25, 25, max_iter = 100, flag = True)
    
    plt.figure(figsize = (10,5))
    plt.plot(evol1, label = 'PALM')
    plt.plot(evol2, label = 'BHTP')
    plt.xlabel('iterations')
    plt.ylabel('error')
    plt.legend(prop={'size' : 15})
    plt.savefig('evol_HTP.png', dpi = 100)
    
    #A, B = MEG_fac(MEG, 2,max_iter = 5000)
    #print(A)
    #A, B = initilization(MEG * 1.0)
    #print(np.linalg.norm(np.dot(A,B) - MEG))
    #print(np.linalg.norm(np.dot(A,B) - MEG) / np.linalg.norm(MEG))
    
    
